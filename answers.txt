1.useState предназначен для управления простым состоянием, тогда как useReducer для сложной логики обновления состояния, особенно когда следующее состояние зависит от предыдущего. useReducer следует использовать при наличии множества действий, изменяющих состояние сложным образом, или когда состояние представляет собой объект со множеством полей.

2.Массив зависимостей в useEffect определяет, при изменении каких переменых хук будет повторно выполнен. Если массив пуст, эффект выполняется только после монтирования компонента. 
Отсутствие массива зависимостей приведет к выполнению эффекта при каждом рендере, что может вызвать проблемы с производительностью.

3."Stale closure" возникает, когда функция внутри хука захватывает устаревшие значения переменных. Для избежания этой проблемы следует использовать функциональные 
обновления в useState и useReducer, которые получают актуальное состояние в качестве аргумента.

4.useCallback и useMemo действительно нужны только при явных проблемах с производительностью, когда дорогостоящие вычисления или передача колбэков вызывают излишние ререндеры.
В большинстве случаев они являются преждевременной оптимизацией и не должны использоваться без необходимости.

5.useRef отличается от useState тем, что изменение значения ref не вызывает ререндер компонента. useRef незаменим для хранения мутируемых значений, которые не влияют на отображение, 
и для прямого доступа к DOM-элементам.

6.Правила хуков требуют их вызова только на верхнем уровне функциональных компонентов и других хуков. Нарушение этих правил приводит к непредсказуемому поведению,
поскольку React полагается на постоянный порядок вызова хуков при каждом рендере.

7.Кастомный хук создается как функция, имя которой начинается с "use". Лучшие практики включают четкое назначение хука, следование принципам композиции и обязательное 
соблюдение правил хуков внутри кастомной реализации.

8.useContext позволяет избежать "пропс-дриллинга" - передачи props через множество промежуточных компонентов. Это упрощает код и делает управление состоянием более предсказуемым, 
особенно для глобальных данных типа темы или аутентификации.

9.Асинхронные операции в кастомных хуках обрабатываются через использование useState для хранения состояния загрузки и данных, useEffect для запуска операций и cleanup-функций для отмены запросов при размонтировании компонента.


10.Отладка хуков осуществляется через React DevTools, которые показывают текущие значения хуков в компонентах, а также с помощью console.log внутри хуков и использования специальных хуков отладки, выводящих историю изменений состояния.

